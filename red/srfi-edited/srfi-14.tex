\section{Character sets}
\redno{6} What character set library should R7RS-large provide?

\begin{quote}
SRFI 14 provides linear-update sets and bags, which can be mutable or
immutable according to the implementer's preference. The contents are
limited to characters.
\end{quote}

\subsection{{Abstract}}\label{abstract}

The ability to efficiently represent and manipulate sets of characters
is an unglamorous but very useful capability for text-processing code --
one that tends to pop up in the definitions of other libraries. Hence it
is useful to specify a general substrate for this functionality early.
This SRFI defines a general library that provides this functionality. It
is accompanied by a reference implementation for the spec. The reference
implementation is fairly efficient, straightforwardly portable, and has
a ``free software'' copyright. The implementation is tuned for ``small''
7 or 8 bit character types, such as ASCII or Latin-1; the data
structures and algorithms would have to be altered for larger 16 or 32
bit character types such as Unicode -- however, the specs have been
carefully designed with these larger character types in mind. Several
forthcoming SRFIs can be defined in terms of this one:

\begin{itemize}
\tightlist
\item
  string library
\item
  delimited input procedures (\emph{e.g.}, \texttt{read-line})
\item
  regular expressions
\end{itemize}

\TODO{is there any “tuning” needed of the spec itself for Unicode, as
  opposed to the reference implementation? I think
  not, but the above paragraph did give me pause. Also, references
  throughout the document are to older versions of the Unicode
  standard. I would hope we would in this document be able to limit
  ourselves to referring only to the Unicode character classes, which
  should only change in new editions of the standard by adding new
  characters to existing classes. If we're not careful, this spec will
  need to be revised for each new edition of the standard.}

\TODO{the “forthcoming” SRFIs listed above do not seem to be included
  in the Red Edition.} 

\TODO{The library name is \texttt{(scheme charset)}, but the names are
  prefixed by \texttt{char-set-...}. Recipe for disaster?}

\setlibname{charset}

\subsection{{Variable Index}}\label{variable-index}

Here is the complete set of bindings -- procedural and otherwise --
exported by this library. In a Scheme system that has a module or
package system, these procedures should be contained in a module named
``char-set-lib''.

\begin{description}
\item[ Predicates \& comparison ]
\begin{verbatim}
char-set? char-set= char-set<= char-set-hash
\end{verbatim}
\item[ Iterating over character sets ]
\begin{verbatim}
char-set-cursor char-set-ref 
char-set-cursor-next end-of-char-set? 
char-set-fold char-set-unfold char-set-unfold!
char-set-for-each char-set-map
\end{verbatim}
\item[ Creating character sets ]
\begin{verbatim}
char-set-copy char-set

list->char-set  string->char-set
list->char-set! string->char-set!
    
char-set-filter  ucs-range->char-set 
char-set-filter! ucs-range->char-set!

->char-set
\end{verbatim}
\item[ Querying character sets ]
\begin{verbatim}
char-set->list char-set->string
char-set-size char-set-count 
char-set-contains?
char-set-every char-set-any
\end{verbatim}
\item[ Character-set algebra ]
\begin{verbatim}
char-set-adjoin  char-set-delete
char-set-adjoin! char-set-delete!

char-set-complement  char-set-union  
char-set-complement! char-set-union! 
char-set-intersection
char-set-intersection!

char-set-difference  char-set-xor  
char-set-difference! char-set-xor! 
char-set-diff+intersection
char-set-diff+intersection!
\end{verbatim}
\item[ Standard character sets ]
\begin{verbatim}
char-set:lower-case  char-set:upper-case  
char-set:title-case
char-set:letter      char-set:digit       
char-set:letter+digit
char-set:graphic     char-set:printing    
char-set:whitespace
char-set:iso-control char-set:punctuation 
char-set:symbol
char-set:hex-digit   char-set:blank       
char-set:ascii
char-set:empty       char-set:full
\end{verbatim}
\end{description}

\subsection{{Specification}}\label{specification}

In the following procedure specifications:

\begin{itemize}
\tightlist
\item
  A cs parameter is a character set.
\item
  An s parameter is a string.
\item
  A char parameter is a character.
\item
  A char-list parameter is a list of characters.
\item
  A pred parameter is a unary character predicate procedure, returning a
  true/false value when applied to a character.
\item
  An obj parameter may be any value at all.
\end{itemize}

Passing values to procedures with these parameters that do not satisfy
these types is an error.

Unless otherwise noted in the specification of a procedure, procedures
always return character sets that are distinct (from the point of view
of the linear-update operations) from the parameter character sets. For
example, \texttt{char-set-adjoin} is guaranteed to provide a fresh
character set, even if it is not given any character parameters.

Parameters given in square brackets are optional. Unless otherwise noted
in the text describing the procedure, any prefix of these optional
parameters may be supplied, from zero arguments to the full list. When a
procedure returns multiple values, this is shown by listing the return
values in square brackets, as well. So, for example, the procedure with
signature

\begin{verbatim}
halts? f [x init-store] -> [boolean integer]
\end{verbatim}

would take one (f), two (f, x) or three (f, x, init-store) input
parameters, and return two values, a boolean and an integer.

\TODO{I'll be changing the entries so they match the R7RS entry
  format, i.e., multiple prototypes for optional arguments.}

A parameter followed by "\texttt{...}" means zero-or-more elements. So
the procedure with the signature

\begin{verbatim}
sum-squares x ...  -> number
\end{verbatim}

takes zero or more arguments (x \ldots{}), while the procedure with
signature

\begin{verbatim}
spell-check doc dict1 dict2 ... -> string-list
\end{verbatim}

takes two required parameters (doc and dict$_1$) and zero
or more optional parameters (dict\textsubscript{2} \ldots{}).

\subsubsection{{General procedures}}\label{general-procedures}

\begin{entry}{%
  \Proto{char-set?}{ obj}{???}{boolean}}

  Is the object obj a character set?
\end{entry}

\begin{entry}{%
  \Proto{char-set=}{ cs$_1$ \ldots{}}{???}{boolean}}

  Are the character sets equal?

  Boundary cases:

\begin{verbatim}
(char-set=) => true
(char-set= cs) => true
\end{verbatim}

  Rationale: transitive binary relations are generally extended to
  n-ary relations in Scheme, which enables clearer, more concise code
  to be written. While the zero-argument and one-argument cases will
  almost certainly not arise in first-order uses of such relations,
  they may well arise in higher-order cases or macro-generated
  code. \emph{E.g.,} consider

\begin{verbatim}
(apply char-set= cset-list)
\end{verbatim}

  This is well-defined if the list is empty or a singleton list. Hence
  we extend these relations to any number of arguments. Implementors
  have reported actual uses of n-ary relations in higher-order cases
  allowing for fewer than two arguments. The way of Scheme is to
  handle the general case; we provide the fully general extension.

  A counter-argument to this extension is that
  \protect\hyperlink{R5RS}{R5RS}'s transitive binary arithmetic
  relations (\texttt{=}, \texttt{<}, \emph{etc.}) require at
  least two arguments, hence this decision is a break with the prior
  convention -- although it is at least one that is
  backwards-compatible.
\end{entry}
\begin{entry}{%
  \Proto{char-set<=}{ cs$_1$ \ldots{}}{???}{boolean}}

  Returns true if every character set
  cs\textsubscript{i} is a subset of character set
  cs\textsubscript{i+1}.

  Boundary cases:

\begin{verbatim}
(char-set<=) => true
(char-set<= cs) => true
\end{verbatim}

  Rationale: See \texttt{char-set=} for discussion of zero- and
  one-argument applications. Consider testing a list of char-sets for
  monotonicity with

\begin{verbatim}
(apply char-set<= cset-list)
\end{verbatim}
\end{entry}
\begin{entry}{%
  \Proto{char-set-hash}{ cs bound}{???}{integer}
  \Rproto{char-set-hash}{ cs}{???}{integer}}

Compute a hash value for the character set cs. Bound is a non-negative
exact integer specifying the range of the hash function. A positive
value restricts the return value to the range {[}0,bound).

If bound is either zero or not given, the implementation may use an
implementation-specific default value, chosen to be as large as is
efficiently practical. For instance, the default range might be chosen
for a given implementation to map all strings into the range of
integers that can be represented with a single machine word.

Invariant:

\begin{verbatim}
(char-set= cs1 cs2) => (= (char-set-hash cs1 b) (char-set-hash cs2 b))
\end{verbatim}

A legal but nonetheless discouraged implementation:

\begin{verbatim}
(define (char-set-hash cs . maybe-bound) 1)
\end{verbatim}

Rationale: allowing the user to specify an explicit bound simplifies
user code by removing the mod operation that typically accompanies
every hash computation, and also may allow the implementation of the
hash function to exploit a reduced range to efficiently compute the
hash value. \emph{E.g.}, for small bounds, the hash function may be
computed in a fashion such that intermediate values never overflow
into bignum integers, allowing the implementor to provide a
fixnum-specific ``fast path'' for computing the common cases very
rapidly.
\end{entry}

\subsubsection{Iterating over character sets}


\begin{entry}{%
  \Proto{char-set-cursor}{ cset}{???}{cursor}
  \Proto{char-set-ref}{ cset cursor}{???}{char}
  \Proto{char-set-cursor-next}{ cset cursor}{???}{cursor}
  \Proto{end-of-char-set?}{ cursor}{???}{boolean}}

  Cursors
  are a low-level facility for iterating over the characters in a
  set. A cursor is a value that indexes a character in a char set.
  \texttt{char-set-cursor} produces a new cursor for a given char
  set. The set element indexed by the cursor is fetched with
  \texttt{char-set-ref}.  A cursor index is incremented with
  \texttt{char-set-cursor-next}; in this way, code can step through
  every character in a char set. Stepping a cursor ``past the end'' of
  a char set produces a cursor that answers true to
  \texttt{end-of-char-set?}. It is an error to pass such a cursor to
  \texttt{char-set-ref} or to \texttt{char-set-cursor-next}.

  A cursor value may not be used in conjunction with a different
  character set; if it is passed to \texttt{char-set-ref} or
  \texttt{char-set-cursor-next} with a character set other than the
  one used to create it, the results and effects are undefined.

  Cursor values are \emph{not} necessarily distinct from other
  types. They may be integers, linked lists, records, procedures or
  other values. This license is granted to allow cursors to be very
  ``lightweight'' values suitable for tight iteration, even in fairly
  simple implementations.

  Note that these primitives are necessary to export an iteration
  facility for char sets to loop macros.

  Example:

\begin{verbatim}
(define cs (char-set #\G #\a #\T #\e #\c #\h))

;; Collect elts of CS into a list.
(let lp ((cur (char-set-cursor cs)) (ans '()))
  (if (end-of-char-set? cur) ans
      (lp (char-set-cursor-next cs cur)
          (cons (char-set-ref cs cur) ans))))
  => (#\G #\T #\a #\c #\e #\h)

;; Equivalently, using a list unfold (from SRFI 1):
(unfold-right end-of-char-set? 
              (curry char-set-ref cs)
          (curry char-set-cursor-next cs)
          (char-set-cursor cs))
  => (#\G #\T #\a #\c #\e #\h)
\end{verbatim}

  Rationale: Note that the cursor API's four functions ``fit'' the
  functional protocol used by the unfolders provided by the list,
  string and char-set SRFIs (see the example above). By way of
  contrast, here is a simpler, two-function API that was rejected for
  failing this criterion. Besides \texttt{char-set-cursor}, it
  provided a single function that mapped a cursor and a character set
  to two values, the indexed character and the next cursor. If the
  cursor had exhausted the character set, then this function returned
  false instead of the character value, and another end-of-char-set
  cursor. In this way, the other three functions of the current API
  were combined together.
\end{entry}

\begin{entry}{%
  \Proto{char-set-fold}{ kons knil cs}{???}{object}}

This is the fundamental iterator for character sets. Applies the
function kons across the character set cs using initial state value
knil. That is, if cs is the empty set, the procedure returns knil.
Otherwise, some element c of cs is chosen; let cs' be the remaining,
unchosen characters. The procedure returns

\begin{verbatim}
(char-set-fold kons (kons c knil) cs')
\end{verbatim}

Examples:

\begin{verbatim}
;; CHAR-SET-MEMBERS
(lambda (cs) (char-set-fold cons '() cs))

;; CHAR-SET-SIZE
(lambda (cs) (char-set-fold (lambda (c i) (+ i 1)) 0 cs))

;; How many vowels in the char set?
(lambda (cs) 
  (char-set-fold (lambda (c i) (if (vowel? c) (+ i 1) i))
                 0 cs))
\end{verbatim}
\end{entry}

\begin{entry}{%
  \Proto{char-set-unfold}{ f p g seed base-cs}{???}{char-set}
  \Rproto{char-set-unfold}{ f p g seed}{???}{char-set}
  \Proto{char-set-unfold!}{ f p g seed base-cs }{???}{ char-set}}

This is a fundamental constructor for char-sets.

\begin{itemize}
  \tightlist
\item G is used to generate a series of ``seed'' values from the
  initial seed: seed, (g seed), (g\textsuperscript{2} seed),
  (g\textsuperscript{3} seed), \ldots{}
\item P tells us when to stop -- when it returns true when applied to
  one of these seed values.
\item F maps each seed value to a character. These characters are
  added to the base character set base-cs to form the result; base-cs
  defaults to the empty set. \texttt{char-set-unfold!} adds the
  characters to base-cs in a linear-update -- it is allowed, but not
  required, to side-effect and use base-cs's storage to construct the
  result.
\end{itemize}

More precisely, the following definitions hold, ignoring the
optional-argument issues:

\begin{verbatim}
(define (char-set-unfold p f g seed base-cs) 
  (char-set-unfold! p f g seed (char-set-copy base-cs)))

(define (char-set-unfold! p f g seed base-cs)
  (let lp ((seed seed) (cs base-cs))
        (if (p seed) cs                                 ; P says we are done.
            (lp (g seed)                                ; Loop on (G SEED).
                (char-set-adjoin! cs (f seed))))))      ; Add (F SEED) to set.
\end{verbatim}

(Note that the actual implementation may be more efficient.)

Examples:

\begin{verbatim}
                         
(port->char-set p) = (char-set-unfold eof-object? values
                                      (lambda (x) (read-char p))
                                      (read-char p))

(list->char-set lis) = (char-set-unfold null? car cdr lis)
\end{verbatim}
\end{entry}
\begin{entry}{%
  \Proto{char-set-for-each}{ proc cs}{???}{unspecified}}

Apply procedure proc to each character in the character set cs. Note
that the order in which proc is applied to the characters in the set
is not specified, and may even change from one procedure application
to another.

Nothing at all is specified about the value returned by this
procedure; it is not even required to be consistent from call to
call. It is simply required to be a value (or values) that may be
passed to a command continuation, \emph{e.g.} as the value of an
expression appearing as a non-terminal subform of a \texttt{begin}
expression. Note that in \protect\hyperlink{R5RS}{R5RS}, this
restricts the procedure to returning a single value; non-R5RS systems
may not even provide this restriction.
\end{entry}

\begin{entry}{%
  \Proto{char-set-map}{ proc cs}{???}{char-set}}

  proc is a
  char-\textgreater{}char procedure. Apply it to all the characters in
  the char-set cs, and collect the results into a new character set.

  Essentially lifts proc from a char-\textgreater{}char procedure to a
  char-set -\textgreater{} char-set procedure.

  Example:

\begin{verbatim}
(char-set-map char-downcase cset)
\end{verbatim}
\end{entry}

\subsubsection{{Creating character sets}}\label{creating-character-sets}

\begin{entry}{%
  \Proto{char-set-copy}{ cs}{???}{char-set}}

  Returns a copy of
  the character set cs. ``Copy'' means that if either the input
  parameter or the result value of this procedure is passed to one of
  the linear-update procedures described below, the other character
  set is guaranteed not to be altered.

  A system that provides pure-functional implementations of the
  linear-operator suite could implement this procedure as the identity
  function -- so copies are \emph{not} guaranteed to be distinct by
  \texttt{eq?}.
\end{entry}

\begin{entry}{%
  \Proto{char-set}{ char$_1$ \ldots}{???}{char-set}}

  Return a
  character set containing the given characters.
\end{entry}

\begin{entry}{%
  \Proto{list->char-set}{ char-list base-cs}{procedure}{char-set}
  \Rproto{list->char-set}{ char-list}{procedure}{char-set}
  \Proto{list->char-set!}{ char-list base-cs}{procedure}{char-set}}

  Return a character set containing the
  characters in the list of characters char-list.

  If character set base-cs is provided, the characters from char-list
  are added to it. \texttt{list->char-set!} is allowed,
  but not required, to side-effect and reuse the storage in base-cs;
  \texttt{list->char-set} produces a fresh character set.    
\end{entry}

\begin{entry}{%
  \Proto{string->char-set}{ s base-cs}{procedure}{char-set}
  \Rproto{string->char-set}{ s}{procedure}{char-set}
  \Proto{string->char-set!}{ s base-cs} {procedure}{char-set}}

  Return a character set containing the characters in the
  string s.

  If character set base-cs is provided, the characters from s are
  added to it. \texttt{string->char-set!} is allowed, but
  not required, to side-effect and reuse the storage in base-cs;
  \texttt{string->char-set} produces a fresh character
  set.    
\end{entry}

\begin{entry}{%
  \Proto{char-set-filter}{ pred cs base-cs}{procedure}{char-set}
  \Rproto{char-set-filter}{ pred cs}{procedure}{char-set}
  \Proto{char-set-filter!}{ pred cs base-cs}{procedure}{char-set}}

  Returns a character set containing every character c in cs such that
  \texttt{(pred\ c)} returns true.

  If character set base-cs is provided, the characters specified by
  pred are added to it. \texttt{char-set-filter!} is allowed, but not
  required, to side-effect and reuse the storage in base-cs;
  \texttt{char-set-filter} produces a fresh character set.

  An implementation may not save away a reference to pred and invoke
  it after \texttt{char-set-filter} or \texttt{char-set-filter!}
  returns -- that is, ``lazy,'' on-demand implementations are not
  allowed, as pred may have external dependencies on mutable data or
  have other side-effects.

  Rationale: This procedure provides a means of converting a character
  predicate into its equivalent character set; the cs parameter allows
  the programmer to bound the predicate's domain. Programmers should
  be aware that filtering a character set such as
  \texttt{char-set:full} could be a very expensive operation in an
  implementation that provided an extremely large character type, such
  as 32-bit Unicode. An earlier draft of this library provided a
  simple \texttt{predicate->char-set} procedure, which
  was rejected in favor of \texttt{char-set-filter} for this reason.
\end{entry}

\begin{entry}{%
  \Proto{ucs-range->char-set}{ lower upper error?
      base-cs}{procedure}{char-set}
  \Rproto{ucs-range->char-set}{ lower upper}{procedure}{char-set}
  \Proto{ucs-range->char-set!}{ lower upper error?
    base-cs}{procedure}{char-set}}

  Lower and upper are exact non-negative
  integers; lower <= upper.

  Returns a character set containing every character whose ISO/IEC
  10646 UCS-4 code lies in the half-open range {[}lower,upper).

\begin{itemize}
  \tightlist
\item If the requested range includes unassigned UCS values, these are
  silently ignored (the current UCS specification has ``holes'' in the
  space of assigned codes).
\item If the requested range includes ``private'' or ``user space''
  codes, these are handled in an implementation-specific manner;
  however, a UCS- or Unicode-based Scheme implementation should pass
  them through transparently.
\item If any code from the requested range specifies a valid, assigned
  UCS character that has no corresponding representative in the
  implementation's character type, then (1) an error is raised if
  error?  is true, and (2) the code is ignored if error? is false (the
  default).  This might happen, for example, if the implementation
  uses ASCII characters, and the requested range includes non-ASCII
  characters.
\end{itemize}

If character set base-cs is provided, the characters specified by the
range are added to it. \texttt{ucs-range->char-set!} is allowed, but
not required, to side-effect and reuse the storage in base-cs;
\texttt{ucs-range->char-set} produces a fresh character set.

Note that ASCII codes are a subset of the Latin-1 codes, which are in
turn a subset of the 16-bit Unicode codes, which are themselves a
subset of the 32-bit UCS-4 codes. We commit to a specific encoding in
this routine, regardless of the underlying representation of
characters, so that client code using this library will be
portable. \emph{I.e.}, a conformant Scheme implementation may use
EBCDIC or SHIFT-JIS to encode characters; it must simply map the UCS
characters from the given range into the native representation when
possible, and report errors when not possible.
\end{entry}

\begin{entry}{%
  \Proto{->char-set}{ x}{procedure}{char-set}}

  Coerces x into
  a char-set. X may be a string, character or char-set. A string is
  converted to the set of its constituent characters; a character is
  converted to a singleton set; a char-set is returned as-is.  This
  procedure is intended for use by other procedures that want to
  provide ``user-friendly,'' wide-spectrum interfaces to their
  clients.
\end{entry}

\subsubsection{Querying character sets}

\begin{entry}{%
  \Proto{char-set-size}{ cs}{procedure}{integer}}

  Returns the
  number of elements in character set cs.
\end{entry}

\begin{entry}{%
  \Proto{char-set-count}{ pred cs}{procedure}{integer}}

  Apply
  pred to the chars of character set cs, and return the number of
  chars that caused the predicate to return true.
\end{entry}

\begin{entry}{%
  \Proto{char-set->list}{ cs}{procedure}{character-list}}

  This procedure returns a list of the members of character set
  cs. The order in which cs's characters appear in the list is not
  defined, and may be different from one call to another.
\end{entry}

\begin{entry}{%
  \Proto{char-set->string}{ cs}{procedure}{string}}

  This
  procedure returns a string containing the members of character set
  cs. The order in which cs's characters appear in the string is not
  defined, and may be different from one call to another.
\end{entry}

\begin{entry}{%
  \Proto{char-set-contains?}{ cs char}{procedure}{boolean}}

  This procedure tests char for membership in character set cs.

  The MIT Scheme character-set package called this procedure
  char-set-member?, but the argument order isn't consistent with the
  name.
\end{entry}

\begin{entry}{%
  \Proto{char-set-every}{ pred cs}{procedure}{boolean}
  \Proto{char-set-any}{ pred cs}{procedure}{boolean}}

  The
  \texttt{char-set-every} procedure returns true if predicate pred
  returns true of every character in the character set cs. Likewise,
  \texttt{char-set-any} applies pred to every character in character
  set cs, and returns the first true value it finds. If no character
  produces a true value, it returns false. The order in which these
  procedures sequence through the elements of cs is not specified.

  Note that if you need to determine the actual character on which a
  predicate returns true, use \texttt{char-set-any} and arrange for
  the predicate to return the character parameter as its true value,
  \emph{e.g.}

\begin{verbatim}
(char-set-any (lambda (c) (and (char-upper-case? c) c)) 
              cs)
\end{verbatim}
\end{entry}

\subsubsection{Character-set algebra}

\begin{entry}{%
  \Proto{char-set-adjoin}{ cs char$_1$ \ldots}{procedure}{char-set}
  \Proto{char-set-delete}{ cs char$_1$ \ldots}{procedure}{char-set}}

  Add/delete the char\textsubscript{i}
  characters to/from character set cs.
\end{entry}

\begin{entry}{%
  \Proto{char-set-adjoin!}{ cs char$_1$ \ldots}{procedure}{char-set}
  \Proto{char-set-delete!}{ cs char$_1$ \ldots}{procedure}{char-set}}

  Linear-update variants. These procedures are allowed, but
  not required, to side-effect their first parameter.
\end{entry}

\begin{entry}{%
  \Proto{char-set-complement}{ cs}{procedure}{char-set}
  \Proto{char-set-union}{ cs$_1$ \ldots}{procedure}{char-set}
  \Proto{char-set-intersection}{ cs$_1$ \ldots}{procedure}{char-set}
  \Proto{char-set-difference}{ cs$_1$ cs$_2$  \ldots}{procedure}{char-set}
  \Proto{char-set-xor}{ cs$_1$ \ldots}{procedure}{char-set}
  \Proto{char-set-diff+intersection}{ cs$_1$ cs$_2$ \ldots}{procedure}{char-set char-set}} 

  These procedures implement
  set complement, union, intersection, difference, and exclusive-or
  for character sets. The union, intersection and xor operations are
  n-ary. The difference function is also n-ary, associates to the left
  (that is, it computes the difference between its first argument and
  the union of all the other arguments), and requires at least one
  argument.

  Boundary cases:

\begin{verbatim}
(char-set-union) => char-set:empty
(char-set-intersection) => char-set:full
(char-set-xor) => char-set:empty
(char-set-difference cs) => cs
\end{verbatim}

  \texttt{char-set-diff+intersection} returns both the difference and
  the intersection of the arguments -- it partitions its first
  parameter. It is equivalent to

\begin{verbatim}
(values (char-set-difference cs1 cs2 ...)
        (char-set-intersection cs1 (char-set-union cs2 ...)))
\end{verbatim}

  but can be implemented more efficiently.

  Programmers should be aware that \texttt{char-set-complement} could
  potentially be a very expensive operation in Scheme implementations
  that provide a very large character type, such as 32-bit Unicode. If
  this is a possibility, sets can be complimented with respect to a
  smaller universe using \texttt{char-set-difference}.
\end{entry}

\begin{entry}{%
  \Proto{char-set-complement!}{ cs}{procedure}{char-set}
  \Proto{char-set-union!}{ cs$_1$ cs$_2$ \ldots}{procedure}{char-set}
  \Proto{char-set-intersection!}{ cs$_1$ cs$_2$ \ldots}{procedure}{char-set}
  \Proto{char-set-difference!}{ cs$_1$ cs$_2$ \ldots}{procedure}{char-set}
  \Proto{char-set-xor!}{ cs$_1$ cs$_2$ \ldots}{procedure}{char-set}
  \Proto{char-set-diff+intersection!}{ cs$_1$ cs$_2$  cs$_3$
    \ldots}{procedure}{char-set char-set}}

   These are linear-update variants of the set-algebra
  functions. They are allowed, but not required, to side-effect their
  first (required) parameter.

  \texttt{char-set-diff+intersection!} is allowed to side-effect both
  of its two required parameters, cs$_1$ and cs$_2$.

  \TODO{why does diff+intersection have cs$_3$?}

\end{entry}

\subsubsection{Standard character sets}

\TODO{Convert to entry format?}

Several character sets are predefined for convenience: 

\begin{tabular}{ll}
\texttt{char-set:lower-case} & Lower-case letters\tabularnewline
\texttt{char-set:upper-case} & Upper-case letters\tabularnewline
\texttt{char-set:title-case} & Title-case letters\tabularnewline
\texttt{char-set:letter} & Letters\tabularnewline
\texttt{char-set:digit} & Digits\tabularnewline
\texttt{char-set:letter+digit} & Letters and digits\tabularnewline
\texttt{char-set:graphic} & Printing characters except
spaces\tabularnewline
\texttt{char-set:printing} & Printing characters including
spaces\tabularnewline
\texttt{char-set:whitespace} & Whitespace characters\tabularnewline
\texttt{char-set:iso-control} & The ISO control
characters\tabularnewline
\texttt{char-set:punctuation} & Punctuation characters\tabularnewline
\texttt{char-set:symbol} & Symbol characters\tabularnewline
\texttt{char-set:hex-digit} & A hexadecimal digit: 0-9, A-F,
a-f\tabularnewline
\texttt{char-set:blank} & Blank characters -- horizontal
whitespace\tabularnewline
\texttt{char-set:ascii} & All characters in the ASCII
set.\tabularnewline
\texttt{char-set:empty} & Empty set\tabularnewline
\texttt{char-set:full} & All characters\tabularnewline
\end{tabular}

Note that there may be characters in \texttt{char-set:letter} that are
neither upper or lower case---this might occur in implementations that
use a character type richer than ASCII, such as Unicode. A ``graphic
character'' is one that would put ink on your page. While the exact
composition of these sets may vary depending upon the character type
provided by the underlying Scheme system, here are the definitions for
some of the sets in an ASCII implementation:

\begin{tabular}{ll}
\texttt{char-set:lower-case} & a-z\tabularnewline
\texttt{char-set:upper-case} & A-Z\tabularnewline
\texttt{char-set:letter} & A-Z and a-z\tabularnewline
\texttt{char-set:digit} & 0123456789\tabularnewline
\texttt{char-set:punctuation} &
\texttt{!"\#\%\&\textquotesingle{}()*,-./:;?@{[}\textbackslash{}{]}\_\{\}}\tabularnewline
\texttt{char-set:symbol} &
\texttt{\$+<=\textgreater{}\^{}`\textbar{}\textasciitilde{}}\tabularnewline
\texttt{char-set:whitespace} & Space, newline, tab, form
feed,\tabularnewline
& vertical tab, carriage return\tabularnewline
\texttt{char-set:blank} & Space and tab\tabularnewline
\texttt{char-set:graphic} & letter + digit + punctuation +
symbol\tabularnewline
\texttt{char-set:printing} & graphic + whitespace\tabularnewline
\texttt{char-set:iso-control} & ASCII 0-31 and 127\tabularnewline
\end{tabular}

Note that the existence of the \texttt{char-set:ascii} set implies that
the underlying character set is required to be at least as rich as ASCII
(including ASCII's control characters).

Rationale: The name choices reflect a shift from the older
``alphabetic/numeric'' terms found in \protect\hyperlink{R5RS}{R5RS} and
Posix to newer, Unicode-influenced ``letter/digit'' lexemes.

\subsubsection{Unicode, Latin-1 and ASCII definitions of the standard character sets}

\TODO{Does this belong here? Would it not be better to refer to
  external Java documentation, and/or Unicode standard?}

In Unicode Scheme implementations, the base character sets are
compatible with Java's Unicode specifications. For ASCII or Latin-1, we
simply restrict the Unicode set specifications to their first 128 or 256
codes, respectively. Scheme implementations that are not based on ASCII,
Latin-1 or Unicode should attempt to preserve the sense or spirit of
these definitions.

The following descriptions frequently make reference to the ``Unicode
character database.'' This is a file, available at URL

\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

Each line contains a description of a Unicode character. The first
semicolon-delimited field of the line gives the hex value of the
character's code; the second field gives the name of the character, and
the third field gives a two-letter category. Other fields give simple
1-1 case-mappings for the character and other information; see

\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}

for further description of the file's format. Note in particular the
two-letter category specified in the the third field, which is
referenced frequently in the descriptions below.

\subsubsection{{\href{}{char-set:lower-case}}{char-set:lower-case}}\label{char-setlower-case}

For Unicode, we follow Java's specification: a character is lowercase if

\begin{itemize}
\tightlist
\item
  it is not in the range {[}U+2000,U+2FFF{]}, and
\item
  the Unicode attribute table does not give a lowercase mapping for it,
  and
\item
  at least one of the following is true:

  \begin{itemize}
  \tightlist
  \item
    the Unicode attribute table gives a mapping to uppercase for the
    character, or
  \item
    the name for the character in the Unicode attribute table contains
    the words ``SMALL LETTER'' or ``SMALL LIGATURE''.
  \end{itemize}
\end{itemize}

The lower-case ASCII characters are

abcdefghijklmnopqrstuvwxyz

Latin-1 adds another 33 lower-case characters to the ASCII set:

\begin{tabular}{ll}
00B5 & MICRO SIGN\tabularnewline
00DF & LATIN SMALL LETTER SHARP S\tabularnewline
00E0 & LATIN SMALL LETTER A WITH GRAVE\tabularnewline
00E1 & LATIN SMALL LETTER A WITH ACUTE\tabularnewline
00E2 & LATIN SMALL LETTER A WITH CIRCUMFLEX\tabularnewline
00E3 & LATIN SMALL LETTER A WITH TILDE\tabularnewline
00E4 & LATIN SMALL LETTER A WITH DIAERESIS\tabularnewline
00E5 & LATIN SMALL LETTER A WITH RING ABOVE\tabularnewline
00E6 & LATIN SMALL LETTER AE\tabularnewline
00E7 & LATIN SMALL LETTER C WITH CEDILLA\tabularnewline
00E8 & LATIN SMALL LETTER E WITH GRAVE\tabularnewline
00E9 & LATIN SMALL LETTER E WITH ACUTE\tabularnewline
00EA & LATIN SMALL LETTER E WITH CIRCUMFLEX\tabularnewline
00EB & LATIN SMALL LETTER E WITH DIAERESIS\tabularnewline
00EC & LATIN SMALL LETTER I WITH GRAVE\tabularnewline
00ED & LATIN SMALL LETTER I WITH ACUTE\tabularnewline
00EE & LATIN SMALL LETTER I WITH CIRCUMFLEX\tabularnewline
00EF & LATIN SMALL LETTER I WITH DIAERESIS\tabularnewline
00F0 & LATIN SMALL LETTER ETH\tabularnewline
00F1 & LATIN SMALL LETTER N WITH TILDE\tabularnewline
00F2 & LATIN SMALL LETTER O WITH GRAVE\tabularnewline
00F3 & LATIN SMALL LETTER O WITH ACUTE\tabularnewline
00F4 & LATIN SMALL LETTER O WITH CIRCUMFLEX\tabularnewline
00F5 & LATIN SMALL LETTER O WITH TILDE\tabularnewline
00F6 & LATIN SMALL LETTER O WITH DIAERESIS\tabularnewline
00F8 & LATIN SMALL LETTER O WITH STROKE\tabularnewline
00F9 & LATIN SMALL LETTER U WITH GRAVE\tabularnewline
00FA & LATIN SMALL LETTER U WITH ACUTE\tabularnewline
00FB & LATIN SMALL LETTER U WITH CIRCUMFLEX\tabularnewline
00FC & LATIN SMALL LETTER U WITH DIAERESIS\tabularnewline
00FD & LATIN SMALL LETTER Y WITH ACUTE\tabularnewline
00FE & LATIN SMALL LETTER THORN\tabularnewline
00FF & LATIN SMALL LETTER Y WITH DIAERESIS\tabularnewline
\end{tabular}

Note that three of these have no corresponding Latin-1 upper-case
character:

\begin{tabular}{ll}
00B5 & MICRO SIGN\tabularnewline
00DF & LATIN SMALL LETTER SHARP S\tabularnewline
00FF & LATIN SMALL LETTER Y WITH DIAERESIS\tabularnewline
\end{tabular}

(The compatibility micro character uppercases to the non-Latin-1 Greek
capital mu; the German sharp s character uppercases to the pair of
characters ``SS,'' and the capital y-with-diaeresis is non-Latin-1.)

(Note that the Java spec for lowercase characters given at

\url{http://java.sun.com/docs/books/jls/html/javalang.doc4.html\#14345}

is inconsistent. U+00B5 MICRO SIGN fulfills the requirements for a
lower-case character (as of Unicode 3.0), but is not given in the
numeric list of lower-case character codes.)

(Note that the Java spec for \texttt{isLowerCase()} given at

\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html\#isLowerCase(char)}

gives three mutually inconsistent definitions of ``lower case.'' The
first is the definition used in this SRFI. Following text says ``A
character is considered to be lowercase if and only if it is specified
to be lowercase by the Unicode 2.0 standard (category Ll in the Unicode
specification data file).'' The former spec excludes U+00AA FEMININE
ORDINAL INDICATOR and U+00BA MASCULINE ORDINAL INDICATOR; the later spec
includes them. Finally, the spec enumerates a list of characters in the
Latin-1 subset; this list excludes U+00B5 MICRO SIGN, which is included
in both of the previous specs.)

\subsubsection{{\href{}{char-set:upper-case}}{char-set:upper-case}}\label{char-setupper-case}

For Unicode, we follow Java's specification: a character is uppercase if

\begin{itemize}
\tightlist
\item
  it is not in the range {[}U+2000,U+2FFF{]}, and
\item
  the Unicode attribute table does not give an uppercase mapping for it
  (this excludes titlecase characters), and
\item
  at least one of the following is true:

  \begin{itemize}
  \tightlist
  \item
    the Unicode attribute table gives a mapping to lowercase for the
    character, or
  \item
    the name for the character in the Unicode attribute table contains
    the words ``CAPITAL LETTER'' or ``CAPITAL LIGATURE''.
  \end{itemize}
\end{itemize}

The upper-case ASCII characters are

ABCDEFGHIJKLMNOPQRSTUVWXYZ

Latin-1 adds another 30 upper-case characters to the ASCII set:

\begin{tabular}{ll}
00C0 & LATIN CAPITAL LETTER A WITH GRAVE\tabularnewline
00C1 & LATIN CAPITAL LETTER A WITH ACUTE\tabularnewline
00C2 & LATIN CAPITAL LETTER A WITH CIRCUMFLEX\tabularnewline
00C3 & LATIN CAPITAL LETTER A WITH TILDE\tabularnewline
00C4 & LATIN CAPITAL LETTER A WITH DIAERESIS\tabularnewline
00C5 & LATIN CAPITAL LETTER A WITH RING ABOVE\tabularnewline
00C6 & LATIN CAPITAL LETTER AE\tabularnewline
00C7 & LATIN CAPITAL LETTER C WITH CEDILLA\tabularnewline
00C8 & LATIN CAPITAL LETTER E WITH GRAVE\tabularnewline
00C9 & LATIN CAPITAL LETTER E WITH ACUTE\tabularnewline
00CA & LATIN CAPITAL LETTER E WITH CIRCUMFLEX\tabularnewline
00CB & LATIN CAPITAL LETTER E WITH DIAERESIS\tabularnewline
00CC & LATIN CAPITAL LETTER I WITH GRAVE\tabularnewline
00CD & LATIN CAPITAL LETTER I WITH ACUTE\tabularnewline
00CE & LATIN CAPITAL LETTER I WITH CIRCUMFLEX\tabularnewline
00CF & LATIN CAPITAL LETTER I WITH DIAERESIS\tabularnewline
00D0 & LATIN CAPITAL LETTER ETH\tabularnewline
00D1 & LATIN CAPITAL LETTER N WITH TILDE\tabularnewline
00D2 & LATIN CAPITAL LETTER O WITH GRAVE\tabularnewline
00D3 & LATIN CAPITAL LETTER O WITH ACUTE\tabularnewline
00D4 & LATIN CAPITAL LETTER O WITH CIRCUMFLEX\tabularnewline
00D5 & LATIN CAPITAL LETTER O WITH TILDE\tabularnewline
00D6 & LATIN CAPITAL LETTER O WITH DIAERESIS\tabularnewline
00D8 & LATIN CAPITAL LETTER O WITH STROKE\tabularnewline
00D9 & LATIN CAPITAL LETTER U WITH GRAVE\tabularnewline
00DA & LATIN CAPITAL LETTER U WITH ACUTE\tabularnewline
00DB & LATIN CAPITAL LETTER U WITH CIRCUMFLEX\tabularnewline
00DC & LATIN CAPITAL LETTER U WITH DIAERESIS\tabularnewline
00DD & LATIN CAPITAL LETTER Y WITH ACUTE\tabularnewline
00DE & LATIN CAPITAL LETTER THORN\tabularnewline
\end{tabular}

\subsubsection{{\href{}{char-set:title-case}}{char-set:title-case}}\label{char-settitle-case}

In Unicode, a character is titlecase if it has the category Lt in the
character attribute database. There are very few of these characters;
here is the entire 31-character list as of Unicode 3.0:

\begin{tabular}{ll}
01C5 & LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH
CARON\tabularnewline
01C8 & LATIN CAPITAL LETTER L WITH SMALL LETTER J\tabularnewline
01CB & LATIN CAPITAL LETTER N WITH SMALL LETTER J\tabularnewline
01F2 & LATIN CAPITAL LETTER D WITH SMALL LETTER Z\tabularnewline
1F88 & GREEK CAPITAL LETTER ALPHA WITH PSILI AND
PROSGEGRAMMENI\tabularnewline
1F89 & GREEK CAPITAL LETTER ALPHA WITH DASIA AND
PROSGEGRAMMENI\tabularnewline
1F8A & GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F8B & GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F8C & GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F8D & GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F8E & GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1F8F & GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1F98 & GREEK CAPITAL LETTER ETA WITH PSILI AND
PROSGEGRAMMENI\tabularnewline
1F99 & GREEK CAPITAL LETTER ETA WITH DASIA AND
PROSGEGRAMMENI\tabularnewline
1F9A & GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F9B & GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1F9C & GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F9D & GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1F9E & GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1F9F & GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1FA8 & GREEK CAPITAL LETTER OMEGA WITH PSILI AND
PROSGEGRAMMENI\tabularnewline
1FA9 & GREEK CAPITAL LETTER OMEGA WITH DASIA AND
PROSGEGRAMMENI\tabularnewline
1FAA & GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1FAB & GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND
PROSGEGRAMMENI\tabularnewline
1FAC & GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1FAD & GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND
PROSGEGRAMMENI\tabularnewline
1FAE & GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1FAF & GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI AND
PROSGEGRAMMENI\tabularnewline
1FBC & GREEK CAPITAL LETTER ALPHA WITH PROSGEGRAMMENI\tabularnewline
1FCC & GREEK CAPITAL LETTER ETA WITH PROSGEGRAMMENI\tabularnewline
1FFC & GREEK CAPITAL LETTER OMEGA WITH PROSGEGRAMMENI\tabularnewline
\end{tabular}

There are no ASCII or Latin-1 titlecase characters.

\subsubsection{{\href{}{char-set:letter}}{char-set:letter}}\label{char-setletter}

In Unicode, a letter is any character with one of the letter categories
(Lu, Ll, Lt, Lm, Lo) in the Unicode character database.

There are 52 ASCII letters

abcdefghijklmnopqrstuvwxyz\\
ABCDEFGHIJKLMNOPQRSTUVWXYZ\\

There are 117 Latin-1 letters. These are the 115 characters that are
members of the Latin-1 \texttt{char-set:lower-case} and
\texttt{char-set:upper-case} sets, plus

\begin{tabular}{ll}
00AA & FEMININE ORDINAL INDICATOR\tabularnewline
00BA & MASCULINE ORDINAL INDICATOR\tabularnewline
\end{tabular}

(These two letters are considered lower-case by Unicode, but not by Java
or SRFI 14.)

\subsubsection{{\href{}{char-set:digit}}{char-set:digit}}\label{char-setdigit}

In Unicode, a character is a digit if it has the category Nd in the
character attribute database. In Latin-1 and ASCII, the only such
characters are 0123456789. In Unicode, there are other digit characters
in other code blocks, such as Gujarati digits and Tibetan digits.

\subsubsection{{\href{}{char-set:hex-digit}}{char-set:hex-digit}}\label{char-sethex-digit}

The only hex digits are 0123456789abcdefABCDEF.

\subsubsection{{\href{}{char-set:letter+digit}}{char-set:letter+digit}}\label{char-setletterdigit}

The union of \texttt{char-set:letter} and \texttt{char-set:digit.}

\subsubsection{{\href{}{char-set:graphic}}{char-set:graphic}}\label{char-setgraphic}

A graphic character is one that would put ink on paper. The ASCII and
Latin-1 graphic characters are the members of

\begin{tabular}{ll}
\texttt{char-set:letter}\tabularnewline
\texttt{char-set:digit}\tabularnewline
\texttt{char-set:punctuation}\tabularnewline
\texttt{char-set:symbol}\tabularnewline
\end{tabular}

\subsubsection{{\href{}{char-set:printing}}{char-set:printing}}\label{char-setprinting}

A printing character is one that would occupy space when printed,
\emph{i.e.}, a graphic character or a space character.
\texttt{char-set:printing} is the union of \texttt{char-set:whitespace}
and \texttt{char-set:graphic.}

\subsubsection{{\href{}{char-set:whitespace}}{char-set:whitespace}}\label{char-setwhitespace}

In Unicode, a whitespace character is either

\begin{itemize}
\tightlist
\item
  a character with one of the space, line, or paragraph separator
  categories (Zs, Zl or Zp) of the Unicode character database.
\item
  U+0009 Horizontal tabulation (\textbackslash{}t control-I)
\item
  U+000A Line feed (\textbackslash{}n control-J)
\item
  U+000B Vertical tabulation (\textbackslash{}v control-K)
\item
  U+000C Form feed (\textbackslash{}f control-L)
\item
  U+000D Carriage return (\textbackslash{}r control-M)
\end{itemize}

There are 24 whitespace characters in Unicode 3.0:

\begin{tabular}{lll}
0009 & HORIZONTAL TABULATION & \textbackslash{}t
control-I\tabularnewline
000A & LINE FEED & \textbackslash{}n control-J\tabularnewline
000B & VERTICAL TABULATION & \textbackslash{}v control-K\tabularnewline
000C & FORM FEED & \textbackslash{}f control-L\tabularnewline
000D & CARRIAGE RETURN & \textbackslash{}r control-M\tabularnewline
0020 & SPACE & Zs\tabularnewline
00A0 & NO-BREAK SPACE & Zs\tabularnewline
1680 & OGHAM SPACE MARK & Zs\tabularnewline
2000 & EN QUAD & Zs\tabularnewline
2001 & EM QUAD & Zs\tabularnewline
2002 & EN SPACE & Zs\tabularnewline
2003 & EM SPACE & Zs\tabularnewline
2004 & THREE-PER-EM SPACE & Zs\tabularnewline
2005 & FOUR-PER-EM SPACE & Zs\tabularnewline
2006 & SIX-PER-EM SPACE & Zs\tabularnewline
2007 & FIGURE SPACE & Zs\tabularnewline
2008 & PUNCTUATION SPACE & Zs\tabularnewline
2009 & THIN SPACE & Zs\tabularnewline
200A & HAIR SPACE & Zs\tabularnewline
200B & ZERO WIDTH SPACE & Zs\tabularnewline
2028 & LINE SEPARATOR & Zl\tabularnewline
2029 & PARAGRAPH SEPARATOR & Zp\tabularnewline
202F & NARROW NO-BREAK SPACE & Zs\tabularnewline
3000 & IDEOGRAPHIC SPACE & Zs\tabularnewline
\end{tabular}

The ASCII whitespace characters are the first six characters in the
above list -- line feed, horizontal tabulation, vertical tabulation,
form feed, carriage return, and space. These are also exactly the
characters recognised by the Posix \texttt{isspace()} procedure. Latin-1
adds the no-break space.

Note: Java's \texttt{isWhitespace()} method is incompatible, including

\begin{tabular}{lll}
0009 & HORIZONTAL TABULATION & (\textbackslash{}t
control-I)\tabularnewline
001C & FILE SEPARATOR & (control-\textbackslash{})\tabularnewline
001D & GROUP SEPARATOR & (control-{]})\tabularnewline
001E & RECORD SEPARATOR & (control-\^{})\tabularnewline
001F & UNIT SEPARATOR & (control-\_)\tabularnewline
\end{tabular}

and excluding

\begin{tabular}{ll}
00A0 & NO-BREAK SPACE\tabularnewline
\end{tabular}

Java's excluding the no-break space means that tokenizers can simply
break character streams at ``whitespace'' boundaries. However, the
exclusion introduces exceptions in other places, \emph{e.g.}
\texttt{char-set:printing} is no longer simply the union of
\texttt{char-set:graphic} and \texttt{char-set:whitespace.}

\subsubsection{{\href{}{char-set:iso-control}}{char-set:iso-control}}\label{char-setiso-control}

The ISO control characters are the Unicode/Latin-1 characters in the
ranges {[}U+0000,U+001F{]} and {[}U+007F,U+009F{]}.

ASCII restricts this set to the characters in the range
{[}U+0000,U+001F{]} plus the character U+007F.

Note that Unicode defines other control characters which do not belong
to this set (hence the qualifying prefix ``iso-'' in the name). This
restriction is compatible with the Java \texttt{IsISOControl()} method.

\subsubsection{{\href{}{char-set:punctuation}}{char-set:punctuation}}\label{char-setpunctuation}

In Unicode, a punctuation character is any character that has one of the
punctuation categories in the Unicode character database (Pc, Pd, Ps,
Pe, Pi, Pf, or Po.)

ASCII has 23 punctuation characters:

\begin{verbatim}
!"#%&'()*,-./:;?@[\]_{}
\end{verbatim}

Latin-1 adds six more:

\begin{tabular}{ll}
00A1 & INVERTED EXCLAMATION MARK\tabularnewline
00AB & LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\tabularnewline
00AD & SOFT HYPHEN\tabularnewline
00B7 & MIDDLE DOT\tabularnewline
00BB & RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\tabularnewline
00BF & INVERTED QUESTION MARK\tabularnewline
\end{tabular}

Note that the nine ASCII characters
\texttt{\$+<=\textgreater{}\^{}`\textbar{}\textasciitilde{}}
are \emph{not} punctuation. They are ``symbols.''

\subsubsection{{\href{}{char-set:symbol}}{char-set:symbol}}\label{char-setsymbol}

In Unicode, a symbol is any character that has one of the symbol
categories in the Unicode character database (Sm, Sc, Sk, or So). There
are nine ASCII symbol characters:

\begin{verbatim}
$+<=>^`|~
\end{verbatim}

Latin-1 adds 18 more:

\begin{tabular}{ll}
00A2 & CENT SIGN\tabularnewline
00A3 & POUND SIGN\tabularnewline
00A4 & CURRENCY SIGN\tabularnewline
00A5 & YEN SIGN\tabularnewline
00A6 & BROKEN BAR\tabularnewline
00A7 & SECTION SIGN\tabularnewline
00A8 & DIAERESIS\tabularnewline
00A9 & COPYRIGHT SIGN\tabularnewline
00AC & NOT SIGN\tabularnewline
00AE & REGISTERED SIGN\tabularnewline
00AF & MACRON\tabularnewline
00B0 & DEGREE SIGN\tabularnewline
00B1 & PLUS-MINUS SIGN\tabularnewline
00B4 & ACUTE ACCENT\tabularnewline
00B6 & PILCROW SIGN\tabularnewline
00B8 & CEDILLA\tabularnewline
00D7 & MULTIPLICATION SIGN\tabularnewline
00F7 & DIVISION SIGN\tabularnewline
\end{tabular}

\subsubsection{{\href{}{char-set:blank}}{char-set:blank}}\label{char-setblank}

Blank chars are horizontal whitespace. In Unicode, a blank character is
either

\begin{itemize}
\tightlist
\item
  a character with the space separator category (Zs) in the Unicode
  character database.
\item
  U+0009 Horizontal tabulation (\textbackslash{}t control-I)
\end{itemize}

There are eighteen blank characters in Unicode 3.0:

\begin{tabular}{lll}
0009 & HORIZONTAL TABULATION & \textbackslash{}t
control-I\tabularnewline
0020 & SPACE & Zs\tabularnewline
00A0 & NO-BREAK SPACE & Zs\tabularnewline
1680 & OGHAM SPACE MARK & Zs\tabularnewline
2000 & EN QUAD & Zs\tabularnewline
2001 & EM QUAD & Zs\tabularnewline
2002 & EN SPACE & Zs\tabularnewline
2003 & EM SPACE & Zs\tabularnewline
2004 & THREE-PER-EM SPACE & Zs\tabularnewline
2005 & FOUR-PER-EM SPACE & Zs\tabularnewline
2006 & SIX-PER-EM SPACE & Zs\tabularnewline
2007 & FIGURE SPACE & Zs\tabularnewline
2008 & PUNCTUATION SPACE & Zs\tabularnewline
2009 & THIN SPACE & Zs\tabularnewline
200A & HAIR SPACE & Zs\tabularnewline
200B & ZERO WIDTH SPACE & Zs\tabularnewline
202F & NARROW NO-BREAK SPACE & Zs\tabularnewline
3000 & IDEOGRAPHIC SPACE & Zs\tabularnewline
\end{tabular}

The ASCII blank characters are the first two characters above --
horizontal tab and space. Latin-1 adds the no-break space.

Java doesn't have the concept of ``blank'' characters, so there are no
compatibility issues.


\subsection{{\href{}{References \&
links}}{References \& links}}\label{references-links}

\begin{description}
\tightlist
\item[\textbf{\href{}{{[}Java{]}}} ]
The following URLs provide documentation on relevant Java classes.\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/lang/StringBuffer.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/text/Collator.html}\\
\url{http://java.sun.com/products/jdk/1.2/docs/api/java/text/package-summary.html}
\item[\textbf{\href{}{{[}MIT-Scheme{]}}} ]
\url{http://www.swiss.ai.mit.edu/projects/scheme/}
\item[\textbf{\href{}{{[}R5RS{]}}}]
Revised\textsuperscript{5} report on the algorithmic language Scheme.\\
R. Kelsey, W. Clinger, J. Rees (editors).\\
Higher-Order and Symbolic Computation, Vol. 11, No. 1, September,
1998.\\
and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998.\\
Available at \url{http://www.schemers.org/Documents/Standards/}.
\item[\textbf{{[}SRFI{]}}]
The SRFI web site.\\
\url{http://srfi.schemers.org/}
\item[\textbf{{[}SRFI-14{]}}]
SRFI-14: String libraries.\\
\url{http://srfi.schemers.org/srfi-14/}

\begin{description}
\tightlist
\item[ This document, in HTML: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14.html}
\item[ This document, in plain text format: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14.txt}
\item[ Source code for the reference implementation: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14.scm}
\item[ Scheme 48 module specification, with typings: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14-s48-module.scm}
\item[ Regression-test suite: ]
\url{http://srfi.schemers.org/srfi-14/srfi-14-tests.scm}
\end{description}
\item[\textbf{\href{}{{[}Unicode{]}}} ]
\url{http://www.unicode.org/}
\item[\textbf{\href{}{{[}UnicodeData{]}}} ]
The Unicode character database.\\
\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}\\
\url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}
\end{description}

